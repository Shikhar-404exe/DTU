from fastapi import FastAPI, Request, HTTPException, Depends, File, UploadFile
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse, StreamingResponse
from pydantic import BaseModel, Field, validator
from sqlalchemy.orm import Session
import requests
import os
from dotenv import load_dotenv
from typing import Optional, Dict, Any, List
import shutil
from pathlib import Path

from database import get_db, init_db
from logging_config import setup_logging, setup_sentry, security_logger
from rate_limiter import limiter, RateLimits
from slowapi.errors import RateLimitExceeded

from chatbot import get_chatbot, ChatMode

from services import get_tts_service, get_stt_service, get_youtube_service
from services.fcm_service import fcm_service

from agents import OfflinePhotoMathAgent

load_dotenv()

logger = setup_logging()
setup_sentry()

try:
    from auth import router as auth_router
    logger.info("âœ“ Auth router loaded successfully")
except Exception as e:
    logger.error(f"âœ— Failed to load auth router: {e}")
    auth_router = None

GROQ_API_KEY = os.getenv("GROQ_API_KEY")

import openai
groq_client = None
ai_model = None

if GROQ_API_KEY:
    try:
        groq_client = openai.OpenAI(
            api_key=GROQ_API_KEY,
            base_url="https://api.groq.com/openai/v1"
        )
        ai_model = "llama-3.3-70b-versatile"
        logger.info("âœ“ Groq AI configured (Llama 3.3 70B) - Fast & Free")
    except Exception as e:
        logger.error(f"âœ— Failed to configure Groq: {e}")
        groq_client = None

if not ai_model:
    logger.warning("âš  No AI models configured - Running in offline mode only")
    logger.info("ðŸ’¡ To enable AI features, configure Groq API key in .env file")

def generate_ai_response(prompt: str, max_tokens: int = 2000, temperature: float = 0.8) -> str:
    """
    Generate AI response using Groq

    Args:
        prompt: User prompt/question
        max_tokens: Maximum tokens to generate
        temperature: Creativity level (0.0-1.0)

    Returns:
        AI generated response
    """
    if not groq_client or not ai_model:
        raise HTTPException(
            status_code=503,
            detail="AI service not configured. Please add Groq API key to enable this feature."
        )

    try:
        response = groq_client.chat.completions.create(
            model=ai_model,
            messages=[{"role": "user", "content": prompt}],
            max_tokens=max_tokens,
            temperature=temperature
        )
        logger.info(f"âœ“ Response generated by Groq (Llama 3.3 70B) - {response.usage.total_tokens} tokens")
        return response.choices[0].message.content
    except Exception as e:
        logger.error(f"âœ— Groq API error: {e}")
        raise HTTPException(
            status_code=503,
            detail=f"AI service temporarily unavailable: {str(e)}"
        )

app = FastAPI(title="SIH2025 API", version="2.0.0")

app.state.limiter = limiter

@app.exception_handler(RateLimitExceeded)
async def rate_limit_handler(request: Request, exc: RateLimitExceeded):
    security_logger.log_event("rate_limit_exceeded", {
        "ip": request.client.host,
        "path": str(request.url.path)
    })
    return JSONResponse(
        status_code=429,
        content={
            "error": "Too many requests",
            "message": "Rate limit exceeded. Please try again later."
        }
    )

@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    logger.error(f"Unhandled exception: {exc}", exc_info=True)
    security_logger.log_event("unhandled_exception", {
        "ip": request.client.host,
        "path": str(request.url.path),
        "error": str(exc)
    })
    return JSONResponse(
        status_code=500,
        content={
            "error": "Internal server error",
            "message": str(exc) if os.getenv("ENVIRONMENT") != "production" else "An error occurred",
            "path": str(request.url)
        }
    )

allowed_origins_str = os.getenv("ALLOWED_ORIGINS", "http://localhost:3000,http://localhost:58010")
allowed_origins = [origin.strip() for origin in allowed_origins_str.split(",")]

logger.info(f"CORS allowed origins: {allowed_origins}")

app.add_middleware(
    CORSMiddleware,
    allow_origins=allowed_origins if os.getenv("ENVIRONMENT") == "production" else ["*"],
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allow_headers=["*"],
    max_age=3600,
)

chatbot_config = {
    'groq_api_key': os.getenv('GROQ_API_KEY'),
    'google_cloud_key': os.getenv('GOOGLE_CLOUD_KEY'),
    'youtube_api_key': os.getenv('YOUTUBE_API_KEY')
}
chatbot = get_chatbot(chatbot_config)

tts_service = get_tts_service(os.getenv('GOOGLE_CLOUD_KEY'))
stt_service = get_stt_service(os.getenv('GOOGLE_CLOUD_KEY'))
youtube_service = get_youtube_service(os.getenv('YOUTUBE_API_KEY'))

photomath_agent = OfflinePhotoMathAgent()

@app.on_event("startup")
async def startup_event():
    """Initialize and validate configuration on startup"""
    logger.info("=" * 60)
    logger.info("ðŸš€ Starting SIH2025 Backend Server")
    logger.info("=" * 60)

    try:
        init_db()
        logger.info("âœ“ Database initialized")
    except Exception as e:
        logger.warning(f"âš  Database initialization warning: {e}")

    if fcm_service.credentials and fcm_service.project_id:
        logger.info(f"âœ“ FCM service configured (Project: {fcm_service.project_id})")
    else:
        logger.warning("âš  FCM service not configured - notifications disabled")

    if GROQ_API_KEY:
        logger.info("âœ“ Groq AI service configured and ready")
    else:
        logger.warning("âš  Groq AI not configured - running in offline mode")

    try:
        health = photomath_agent.health_check()
        if health.get("status") == "healthy":
            logger.info("âœ“ PhotoMath agent ready")
        else:
            logger.warning("âš  PhotoMath agent not fully configured")
    except Exception as e:
        logger.warning(f"âš  PhotoMath agent warning: {e}")

    logger.info("=" * 60)
    logger.info("âœ… Server startup complete")
    logger.info("=" * 60)

@app.on_event("shutdown")
async def shutdown_event():
    """Cleanup on shutdown"""
    logger.info("ðŸ›‘ Shutting down SIH2025 Backend Server")

UPLOAD_DIR = Path("uploads/math_images")
UPLOAD_DIR.mkdir(parents=True, exist_ok=True)

@app.on_event("startup")
async def startup_event():
    """Initialize database and perform health checks"""
    try:
        logger.info("ðŸš€ Starting application...")
        init_db()
        logger.info("âœ“ Database initialized successfully")
        logger.info("âœ“ Chatbot initialized successfully")
    except Exception as e:
        logger.error(f"âœ— Database initialization failed: {e}")
        raise

if auth_router:
    app.include_router(auth_router, prefix="/auth", tags=["auth"])
    logger.info("âœ“ Auth routes mounted")
else:
    logger.warning("âš  Auth routes not available")

@app.get("/")
@limiter.limit(RateLimits.HEALTH)
async def root(request: Request):
    """Root endpoint for health check"""
    return {
        "status": "online",
        "service": "SIH2025 API",
        "version": "2.0.0",
        "environment": os.getenv("ENVIRONMENT", "development"),
        "groq_status": "available" if ai_model else "unavailable"
    }

@app.get("/health")
@limiter.limit(RateLimits.HEALTH)
async def health_check(request: Request, db: Session = Depends(get_db)):
    """Detailed health check endpoint with database status"""
    db_healthy = False
    try:
        db.execute("SELECT 1")
        db_healthy = True
    except Exception as e:
        logger.error(f"Database health check failed: {e}")

    return {
        "status": "healthy" if db_healthy else "degraded",
        "services": {
            "database": db_healthy,
            "ai_service": ai_model is not None,
            "auth": auth_router is not None
        }
    }

@app.get("/ping")
@limiter.limit(RateLimits.HEALTH)
async def ping(request: Request):
    """
    Returns the server's IP and port as seen by the client.
    Helps Flutter auto-detect backend without hardcoding.
    """
    return {
        "status": "ok",
        "server_ip": request.url.hostname,
        "server_port": request.url.port or 8000,
        "timestamp": str(requests.utils.default_headers())
    }

class NoteRequest(BaseModel):
    subject: str = Field(..., min_length=1, max_length=100)
    board: str = Field(..., min_length=1, max_length=100)
    class_: str = Field(..., min_length=1, max_length=50)
    topic: str = Field(..., min_length=1, max_length=200)
    additionalDetail: str = Field(default="", max_length=500)
    language: str = Field(default="English", min_length=1, max_length=50)
    detailedness: float = Field(default=0.5, ge=0.0, le=1.0)

    @validator('detailedness')
    def validate_detailedness(cls, v):
        if not 0.0 <= v <= 1.0:
            raise ValueError('detailedness must be between 0 and 1')
        return v

@app.post("/generate-note")
@limiter.limit(RateLimits.GENERATE_NOTE)
async def generate_note(req: NoteRequest, request: Request, db: Session = Depends(get_db)):
    """Generate educational notes using DeepSeek AI with rate limiting"""
    try:
        security_logger.log_event("note_generation_request", {
            "ip": request.client.host,
            "subject": req.subject,
            "topic": req.topic
        })

        req.subject = req.subject.strip()[:100]
        req.topic = req.topic.strip()[:200]
        req.additionalDetail = req.additionalDetail.strip()[:500]

        if not ai_model:
            raise HTTPException(
                status_code=503,
                detail="AI service not configured. Please configure an AI API key to use this feature."
            )

        detail_level = (
            "Basic" if req.detailedness < 0.25 else
            "Moderate" if req.detailedness < 0.5 else
            "Detailed" if req.detailedness < 0.75 else
            "Very Detailed"
        )

        logger.info(f"Generating {detail_level} notes for {req.subject} - {req.topic}")

        max_retries = 3
        note = None
        quiz_metadata = None

        for attempt in range(max_retries):
            try:

                notes_prompt = f"""
                You are a helpful teacher creating structured notes for students.

                Generate {detail_level} educational notes in {req.language}.
                Subject: {req.subject}
                Board/University: {req.board}
                Class/Semester: {req.class_}
                Topic: {req.topic}
                Additional details: {req.additionalDetail}

                Please provide well-structured, clear, and informative notes.
                """

                note = generate_ai_response(notes_prompt)
                note = note.strip()

                if not note:
                    raise ValueError("Empty response from AI")

                logger.info(f"âœ“ Notes generated successfully (attempt {attempt + 1})")

                quiz_prompt = f"""
                Based on these notes about {req.topic} in {req.subject}, generate quiz metadata in JSON format.

                Notes:
                {note[:1000]}  # Use first 1000 chars to stay within token limit

                Generate exactly this JSON structure:
                {{
                  "keyPoints": ["point1", "point2", "point3"],
                  "keywords": ["keyword1", "keyword2", "keyword3"],
                  "questionTemplates": [
                    {{
                      "question": "What is...?",
                      "options": ["option1", "option2", "option3", "option4"],
                      "correctAnswer": "option1",
                      "explanation": "Because...",
                      "type": "mcq"
                    }}
                  ],
                  "difficulty": "medium"
                }}

                Generate 5-10 questions of types: mcq, true_false, short_answer.
                Return ONLY valid JSON, no other text.
                """

                try:
                    quiz_text = generate_ai_response(quiz_prompt)
                    quiz_text = quiz_text.strip()

                    if '```json' in quiz_text:
                        quiz_text = quiz_text.split('```json')[1].split('```')[0].strip()
                    elif '```' in quiz_text:
                        quiz_text = quiz_text.split('```')[1].split('```')[0].strip()

                    import json
                    quiz_metadata = json.loads(quiz_text)

                    quiz_metadata['board'] = req.board
                    quiz_metadata['classLevel'] = req.class_

                    logger.info(f"âœ“ Quiz metadata generated: {len(quiz_metadata.get('questionTemplates', []))} questions")
                except Exception as quiz_error:
                    logger.warning(f"Quiz metadata generation failed: {quiz_error}")

                    quiz_metadata = None

                break

            except Exception as e:
                logger.warning(f"Attempt {attempt + 1} failed: {e}")
                if attempt == max_retries - 1:
                    raise HTTPException(
                        status_code=500,
                        detail=f"Failed to generate notes after {max_retries} attempts: {str(e)}"
                    )

        return {
            "note": note,
            "detail_level": detail_level,
            "quizMetadata": quiz_metadata,
            "success": True
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Unexpected error in generate_note: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"An unexpected error occurred: {str(e)}"
        )

class ChatSessionCreate(BaseModel):
    """Request model for creating chat session"""
    user_id: str = Field(..., description="User identifier")
    mode: str = Field(default="auto", description="Chat mode: offline/online/auto")
    metadata: Optional[Dict[str, Any]] = None

class ChatMessage(BaseModel):
    """Request model for chat message"""
    session_id: str = Field(..., description="Session identifier")
    message: str = Field(..., description="User message", min_length=1)
    context: Optional[Dict[str, Any]] = Field(default=None, description="Additional context")
    mode: Optional[str] = Field(default=None, description="Override chat mode")

class SessionUpdate(BaseModel):
    """Request model for updating session"""
    title: Optional[str] = None

@app.post("/chatbot/session")
@limiter.limit(RateLimits.DEFAULT)
async def create_chat_session(
    request: Request,
    session_data: ChatSessionCreate
):
    """
    Create new chat session

    - **user_id**: User identifier
    - **mode**: Chat mode (offline/online/auto)
    - **metadata**: Optional session metadata
    """
    try:
        mode = ChatMode(session_data.mode)
        session_id = chatbot.create_session(
            user_id=session_data.user_id,
            mode=mode,
            metadata=session_data.metadata
        )

        logger.info(f"Created chat session {session_id} for user {session_data.user_id}")

        return {
            "success": True,
            "session_id": session_id,
            "mode": session_data.mode,
            "created_at": "now"
        }

    except ValueError as e:
        raise HTTPException(status_code=400, detail=f"Invalid mode: {session_data.mode}")
    except Exception as e:
        logger.error(f"Failed to create session: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/chatbot/chat")
@limiter.limit(RateLimits.DEFAULT)
async def chat_endpoint(
    request: Request,
    chat_data: ChatMessage
):
    """
    Send message to chatbot

    - **session_id**: Session identifier
    - **message**: User message
    - **context**: Optional context (language, subject, etc.)
    - **mode**: Optional mode override
    """
    try:
        mode = ChatMode(chat_data.mode) if chat_data.mode else None

        response = chatbot.chat(
            session_id=chat_data.session_id,
            user_message=chat_data.message,
            context=chat_data.context,
            mode=mode
        )

        logger.info(f"Chat response for session {chat_data.session_id}: "
                   f"success={response.get('success')}, "
                   f"agent={response.get('agent_id')}")

        return response

    except Exception as e:
        logger.error(f"Chat error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/chatbot/session/{session_id}/history")
@limiter.limit(RateLimits.DEFAULT)
async def get_session_history(
    request: Request,
    session_id: str,
    limit: Optional[int] = None
):
    """
    Get conversation history for session

    - **session_id**: Session identifier
    - **limit**: Optional message limit
    """
    try:
        history = chatbot.get_session_history(session_id, limit)

        return {
            "success": True,
            "session_id": session_id,
            "message_count": len(history),
            "messages": history
        }

    except Exception as e:
        logger.error(f"Failed to get history: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/chatbot/user/{user_id}/sessions")
@limiter.limit(RateLimits.DEFAULT)
async def get_user_sessions(
    request: Request,
    user_id: str,
    limit: int = 50
):
    """
    Get user's chat sessions

    - **user_id**: User identifier
    - **limit**: Maximum sessions to return
    """
    try:
        sessions = chatbot.get_user_sessions(user_id, limit)

        return {
            "success": True,
            "user_id": user_id,
            "session_count": len(sessions),
            "sessions": sessions
        }

    except Exception as e:
        logger.error(f"Failed to get sessions: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@app.patch("/chatbot/session/{session_id}")
@limiter.limit(RateLimits.DEFAULT)
async def update_session(
    request: Request,
    session_id: str,
    update_data: SessionUpdate
):
    """
    Update chat session

    - **session_id**: Session identifier
    - **title**: New session title
    """
    try:
        if update_data.title:
            chatbot.update_session_title(session_id, update_data.title)

        return {
            "success": True,
            "session_id": session_id,
            "updated": True
        }

    except Exception as e:
        logger.error(f"Failed to update session: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@app.delete("/chatbot/session/{session_id}")
@limiter.limit(RateLimits.DEFAULT)
async def delete_session(
    request: Request,
    session_id: str
):
    """
    Delete chat session

    - **session_id**: Session identifier
    """
    try:
        chatbot.delete_session(session_id)

        return {
            "success": True,
            "session_id": session_id,
            "deleted": True
        }

    except Exception as e:
        logger.error(f"Failed to delete session: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/chatbot/user/{user_id}/search")
@limiter.limit(RateLimits.DEFAULT)
async def search_conversations(
    request: Request,
    user_id: str,
    query: str,
    limit: int = 20
):
    """
    Search user's conversation history

    - **user_id**: User identifier
    - **query**: Search query
    - **limit**: Maximum results
    """
    try:
        results = chatbot.search_conversations(user_id, query, limit)

        return {
            "success": True,
            "user_id": user_id,
            "query": query,
            "result_count": len(results),
            "results": results
        }

    except Exception as e:
        logger.error(f"Search failed: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/chatbot/stats")
@limiter.limit(RateLimits.DEFAULT)
async def get_chatbot_stats(request: Request):
    """Get chatbot statistics"""
    try:
        stats = chatbot.get_stats()

        return {
            "success": True,
            "stats": stats
        }

    except Exception as e:
        logger.error(f"Failed to get stats: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/chatbot/health")
@limiter.limit(RateLimits.HEALTH)
async def chatbot_health_check(request: Request):
    """Check chatbot health"""
    try:
        health = chatbot.health_check()

        status_code = 200 if health.get('chatbot') == 'healthy' else 503

        return JSONResponse(
            status_code=status_code,
            content={
                "success": True,
                "health": health
            }
        )

    except Exception as e:
        logger.error(f"Health check failed: {e}", exc_info=True)
        return JSONResponse(
            status_code=503,
            content={
                "success": False,
                "error": str(e)
            }
        )

from agents import get_orchestrator, AgentMode

orchestrator_config = {
    'gemini_api_key': os.getenv('GEMINI_API_KEY'),
    'google_cloud_key': os.getenv('GOOGLE_CLOUD_KEY'),
    'youtube_api_key': os.getenv('YOUTUBE_API_KEY')
}
orchestrator = get_orchestrator(orchestrator_config)

from tools import get_knowledge_base, get_cache_manager, get_syllabus_parser
orchestrator.init_tools(
    knowledge_base=get_knowledge_base(),
    cache_manager=get_cache_manager(),
    syllabus_parser=get_syllabus_parser()
)
logger.info("âœ“ Agent Orchestrator initialized with 9 agents and 3 custom tools")

class OrchestratorQueryRequest(BaseModel):
    """Request model for orchestrator query"""
    query: str = Field(..., description="User query to process")
    context: Optional[Dict[str, Any]] = Field(default=None, description="Additional context")
    preferred_agent: Optional[str] = Field(default=None, description="Preferred agent ID")
    mode: str = Field(default='auto', description="Agent mode: offline, online, auto")

class AgentQueryRequest(BaseModel):
    """Request model for specific agent query"""
    query: str = Field(..., description="User query to process")
    context: Optional[Dict[str, Any]] = Field(default=None, description="Additional context")

@app.get("/orchestrator/agents")
@limiter.limit(RateLimits.DEFAULT)
async def get_all_agents(request: Request):
    """
    Get list of all registered agents

    Returns information about all 9 agents in the multi-agent system
    """
    try:
        agents_info = []
        for agent_id, agent in orchestrator.agents.items():
            agents_info.append({
                'agent_id': agent.agent_id,
                'name': agent.name,
                'description': agent.description,
                'capabilities': [cap.value for cap in agent.capabilities],
                'priority': agent.priority.name.lower(),
                'default_mode': agent.default_mode.value,
                'stats': agent.stats
            })

        return {
            'success': True,
            'agent_count': len(agents_info),
            'agents': agents_info
        }

    except Exception as e:
        logger.error(f"Failed to get agents: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/orchestrator/stats")
@limiter.limit(RateLimits.DEFAULT)
async def get_orchestrator_stats(request: Request):
    """
    Get orchestrator statistics

    Returns usage statistics for the multi-agent system
    """
    try:
        return {
            'success': True,
            'stats': orchestrator.stats,
            'agent_count': len(orchestrator.agents),
            'tools_initialized': orchestrator.knowledge_base is not None
        }

    except Exception as e:
        logger.error(f"Failed to get orchestrator stats: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/orchestrator/process")
@limiter.limit(RateLimits.DEFAULT)
async def process_orchestrator_query(
    request: Request,
    query_request: OrchestratorQueryRequest
):
    """
    Process query through the orchestrator

    Routes query to the most appropriate agent based on:
    - Query content analysis
    - Agent capabilities matching
    - Current mode (offline/online/auto)
    """
    try:

        try:
            mode = AgentMode(query_request.mode)
        except ValueError:
            mode = AgentMode.AUTO

        context = query_request.context or {}
        context['mode'] = mode.value

        if query_request.preferred_agent:
            context['preferred_agent'] = query_request.preferred_agent

        response = orchestrator.process_query(
            query=query_request.query,
            context=context
        )

        return {
            'success': response.get('success', False),
            'response': response.get('answer') or response.get('response'),
            'agent_id': response.get('agent_id'),
            'agent_name': response.get('agent_name'),
            'mode': response.get('mode'),
            'confidence': response.get('confidence'),
            'metadata': response.get('metadata')
        }

    except Exception as e:
        logger.error(f"Orchestrator query failed: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/agents/{agent_id}")
@limiter.limit(RateLimits.DEFAULT)
async def get_agent_info(request: Request, agent_id: str):
    """
    Get information about a specific agent

    - **agent_id**: Agent identifier (e.g., 'study_assistant', 'offline_knowledge')
    """
    try:
        if agent_id not in orchestrator.agents:
            raise HTTPException(status_code=404, detail=f"Agent '{agent_id}' not found")

        agent = orchestrator.agents[agent_id]

        return {
            'success': True,
            'agent': {
                'agent_id': agent.agent_id,
                'name': agent.name,
                'description': agent.description,
                'capabilities': [cap.value for cap in agent.capabilities],
                'priority': agent.priority.name.lower(),
                'default_mode': agent.default_mode.value,
                'current_mode': agent.current_mode.value,
                'stats': agent.stats
            }
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get agent info: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/agents/{agent_id}/stats")
@limiter.limit(RateLimits.DEFAULT)
async def get_agent_stats(request: Request, agent_id: str):
    """
    Get statistics for a specific agent

    - **agent_id**: Agent identifier
    """
    try:
        if agent_id not in orchestrator.agents:
            raise HTTPException(status_code=404, detail=f"Agent '{agent_id}' not found")

        agent = orchestrator.agents[agent_id]

        return {
            'success': True,
            'agent_id': agent_id,
            'stats': agent.stats
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get agent stats: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/agents/{agent_id}/process")
@limiter.limit(RateLimits.DEFAULT)
async def process_agent_query(
    request: Request,
    agent_id: str,
    query_request: AgentQueryRequest
):
    """
    Process query with a specific agent

    - **agent_id**: Agent identifier
    - Bypasses orchestrator routing and sends directly to specified agent
    """
    try:
        if agent_id not in orchestrator.agents:
            raise HTTPException(status_code=404, detail=f"Agent '{agent_id}' not found")

        agent = orchestrator.agents[agent_id]

        response = agent.process(
            query=query_request.query,
            context=query_request.context or {}
        )

        return {
            'success': response.get('success', False),
            'response': response.get('answer') or response.get('response') or response.get('message'),
            'agent_id': agent_id,
            'agent_name': agent.name,
            'mode': response.get('mode'),
            'confidence': response.get('confidence'),
            'metadata': response
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Agent query failed: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/tools")
@limiter.limit(RateLimits.DEFAULT)
async def get_all_tools(request: Request):
    """
    Get list of all custom tools

    Returns information about all 3 custom tools in the system
    """
    try:
        tools_info = [
            {
                'tool_id': 'offline_knowledge_base',
                'name': 'Offline Knowledge Base',
                'description': 'Semantic search and cached Q&A for offline operation',
                'capabilities': ['semantic_search', 'offline_storage'],
                'supports_offline': True,
                'version': '1.0.0'
            },
            {
                'tool_id': 'cache_manager',
                'name': 'Smart Cache Manager',
                'description': 'Content synchronization for low-bandwidth scenarios',
                'capabilities': ['caching', 'content_sync', 'offline_storage'],
                'supports_offline': True,
                'version': '1.0.0'
            },
            {
                'tool_id': 'syllabus_parser',
                'name': 'Syllabus Parser & Study Path Generator',
                'description': 'Parses syllabus and generates personalized learning paths',
                'capabilities': ['syllabus_parsing', 'study_path_generation'],
                'supports_offline': True,
                'version': '1.0.0'
            }
        ]

        return {
            'success': True,
            'tool_count': len(tools_info),
            'tools': tools_info
        }

    except Exception as e:
        logger.error(f"Failed to get tools: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

class KnowledgeSearchRequest(BaseModel):
    """Request model for knowledge base search"""
    query: str = Field(..., description="Search query")
    subject: Optional[str] = Field(default=None, description="Filter by subject")
    language: str = Field(default='en', description="Language code")
    limit: int = Field(default=5, ge=1, le=20, description="Max results")

@app.post("/tools/knowledge/search")
@limiter.limit(RateLimits.DEFAULT)
async def search_knowledge_base(
    request: Request,
    search_request: KnowledgeSearchRequest
):
    """
    Search the offline knowledge base

    Uses semantic search to find relevant Q&A pairs
    """
    try:
        kb = get_knowledge_base()

        results = kb.search(
            query=search_request.query,
            limit=search_request.limit,
            subject=search_request.subject,
            language=search_request.language
        )

        return {
            'success': True,
            'query': search_request.query,
            'result_count': len(results),
            'results': results
        }

    except Exception as e:
        logger.error(f"Knowledge search failed: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/tools/knowledge/stats")
@limiter.limit(RateLimits.DEFAULT)
async def get_knowledge_base_stats(request: Request):
    """Get knowledge base statistics"""
    try:
        kb = get_knowledge_base()
        stats = kb.get_stats()

        return {
            'success': True,
            'stats': stats
        }

    except Exception as e:
        logger.error(f"Failed to get KB stats: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/tools/cache/status")
@limiter.limit(RateLimits.DEFAULT)
async def get_cache_status(request: Request):
    """Get cache manager status"""
    try:
        cache = get_cache_manager()
        status = cache.get_sync_stats()

        return {
            'success': True,
            'status': 'healthy',
            'stats': status
        }

    except Exception as e:
        logger.error(f"Failed to get cache status: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

class StudyPathRequest(BaseModel):
    """Request model for study path generation"""
    user_id: str = Field(..., description="User identifier")
    subject: str = Field(..., description="Subject name")
    grade_level: str = Field(default='10', description="Grade level")
    available_hours_per_week: int = Field(default=10, ge=1, le=40, description="Available study hours per week")
    target_weeks: int = Field(default=12, ge=1, le=52, description="Target duration in weeks")

@app.post("/tools/syllabus/study-path")
@limiter.limit(RateLimits.DEFAULT)
async def generate_study_path(
    request: Request,
    path_request: StudyPathRequest
):
    """
    Generate a personalized study path

    Creates an optimized learning path based on syllabus topics
    """
    try:
        parser = get_syllabus_parser()

        result = parser.generate_optimal_study_path(
            user_id=path_request.user_id,
            subject=path_request.subject,
            grade_level=path_request.grade_level,
            available_hours_per_week=path_request.available_hours_per_week,
            target_weeks=path_request.target_weeks
        )

        if 'error' in result:
            raise HTTPException(status_code=400, detail=result['error'])

        path_details = parser.get_study_path_details(result['path_id'])

        return {
            'success': True,
            'study_path': {
                'path_id': result['path_id'],
                'subject': path_request.subject,
                'grade_level': path_request.grade_level,
                'total_topics': result['total_topics'],
                'estimated_hours': result['estimated_hours'],
                'items': path_details.get('items', [])
            }
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Study path generation failed: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/tools/syllabus/topics")
@limiter.limit(RateLimits.DEFAULT)
async def get_syllabus_topics(
    request: Request,
    subject: str,
    grade: str = '10',
    board: Optional[str] = None
):
    """
    Get syllabus topics for a subject
    """
    try:
        parser = get_syllabus_parser()

        topics = parser.get_syllabus_topics(
            subject=subject,
            grade_level=grade
        )

        return {
            'success': True,
            'subject': subject,
            'grade': grade,
            'topic_count': len(topics),
            'topics': topics
        }

    except Exception as e:
        logger.error(f"Failed to get topics: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

class TTSRequest(BaseModel):
    """Request model for TTS"""
    text: str = Field(..., description="Text to synthesize", min_length=1)
    language: str = Field(default='en', description="Language code (en, hi, pa, etc.)")
    voice: Optional[str] = Field(default=None, description="Specific voice name")
    speed: float = Field(default=1.0, ge=0.25, le=4.0, description="Speech rate")
    pitch: float = Field(default=0.0, ge=-20.0, le=20.0, description="Voice pitch")
    use_online: bool = Field(default=True, description="Use Google Cloud TTS")

@app.post("/tts/synthesize")
@limiter.limit(RateLimits.DEFAULT)
async def tts_synthesize(
    request: Request,
    tts_data: TTSRequest
):
    """
    Convert text to speech

    - **text**: Text to synthesize
    - **language**: Language code (en, hi, pa, ta, te, bn, mr, gu)
    - **voice**: Optional specific voice
    - **speed**: Speech rate (0.25-4.0)
    - **pitch**: Voice pitch (-20.0 to 20.0)
    - **use_online**: Use Google Cloud TTS if available
    """
    try:
        result = tts_service.synthesize(
            text=tts_data.text,
            language=tts_data.language,
            voice=tts_data.voice,
            speed=tts_data.speed,
            pitch=tts_data.pitch,
            use_online=tts_data.use_online
        )

        logger.info(f"TTS synthesis: provider={result.get('provider')}, "
                   f"language={tts_data.language}, "
                   f"text_length={len(tts_data.text)}")

        return result

    except Exception as e:
        logger.error(f"TTS error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/tts/voices")
@limiter.limit(RateLimits.DEFAULT)
async def tts_get_voices(
    request: Request,
    language: Optional[str] = None
):
    """
    Get available TTS voices

    - **language**: Optional language filter
    """
    try:
        voices = tts_service.get_voices(language)

        return {
            "success": True,
            "voice_count": len(voices),
            "voices": voices
        }

    except Exception as e:
        logger.error(f"Failed to get voices: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/tts/health")
@limiter.limit(RateLimits.HEALTH)
async def tts_health_check(request: Request):
    """Check TTS service health"""
    try:
        health = tts_service.health_check()
        return {"success": True, "health": health}
    except Exception as e:
        logger.error(f"TTS health check failed: {e}", exc_info=True)
        return JSONResponse(
            status_code=503,
            content={"success": False, "error": str(e)}
        )

class STTRequest(BaseModel):
    """Request model for STT"""
    audio_base64: str = Field(..., description="Base64-encoded audio data")
    language: str = Field(default='en-IN', description="Language code (en-IN, hi-IN, etc.)")
    encoding: str = Field(default='LINEAR16', description="Audio encoding")
    sample_rate: int = Field(default=16000, description="Sample rate in Hz")
    use_online: bool = Field(default=True, description="Use Google Cloud STT")

@app.post("/stt/recognize")
@limiter.limit(RateLimits.DEFAULT)
async def stt_recognize(
    request: Request,
    stt_data: STTRequest
):
    """
    Convert speech to text

    - **audio_base64**: Base64-encoded audio data
    - **language**: Language code (en-IN, hi-IN, pa-IN, etc.)
    - **encoding**: Audio encoding (LINEAR16, MP3, OGG_OPUS, FLAC)
    - **sample_rate**: Sample rate in Hz (usually 16000)
    - **use_online**: Use Google Cloud STT if available
    """
    try:
        result = stt_service.recognize(
            audio_base64=stt_data.audio_base64,
            language=stt_data.language,
            encoding=stt_data.encoding,
            sample_rate=stt_data.sample_rate,
            use_online=stt_data.use_online
        )

        logger.info(f"STT recognition: provider={result.get('provider')}, "
                   f"language={stt_data.language}")

        return result

    except Exception as e:
        logger.error(f"STT error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/stt/languages")
@limiter.limit(RateLimits.DEFAULT)
async def stt_get_languages(request: Request):
    """Get supported STT languages"""
    try:
        languages = stt_service.get_supported_languages()

        return {
            "success": True,
            "language_count": len(languages),
            "languages": languages
        }

    except Exception as e:
        logger.error(f"Failed to get languages: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/stt/health")
@limiter.limit(RateLimits.HEALTH)
async def stt_health_check(request: Request):
    """Check STT service health"""
    try:
        health = stt_service.health_check()
        return {"success": True, "health": health}
    except Exception as e:
        logger.error(f"STT health check failed: {e}", exc_info=True)
        return JSONResponse(
            status_code=503,
            content={"success": False, "error": str(e)}
        )

@app.post("/photomath/solve")
@limiter.limit(RateLimits.DEFAULT)
async def photomath_solve(
    request: Request,
    image: UploadFile = File(..., description="Math problem image")
):
    """
    Solve math problem from image - FULLY OFFLINE

    Uses OCR (Tesseract) + SymPy for symbolic math solving
    - **image**: Image file containing math problem

    Returns:
    - extracted_text: Text extracted from image
    - parsed_expressions: Identified math expressions
    - solutions: Step-by-step solutions with answer
    """
    temp_file_path = None

    try:

        if not image.content_type.startswith('image/'):
            raise HTTPException(
                status_code=400,
                detail="File must be an image (jpg, png, etc.)"
            )

        file_extension = Path(image.filename).suffix
        temp_file_path = UPLOAD_DIR / f"temp_{os.urandom(8).hex()}{file_extension}"

        with temp_file_path.open("wb") as buffer:
            shutil.copyfileobj(image.file, buffer)

        logger.info(f"Processing math image: {image.filename}")

        result = photomath_agent.process_offline(
            query="solve math problem from image",
            context={
                "image_path": str(temp_file_path),
                "has_image": True
            }
        )

        logger.info(f"PhotoMath result: success={result.get('success')}, "
                   f"solutions={len(result.get('solutions', []))}")

        return result

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"PhotoMath solve error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

    finally:

        if temp_file_path and temp_file_path.exists():
            try:
                temp_file_path.unlink()
            except Exception as e:
                logger.error(f"Failed to delete temp file: {e}")

@app.get("/photomath/health")
@limiter.limit(RateLimits.HEALTH)
async def photomath_health_check(request: Request):
    """Check PhotoMath service health"""
    try:

        can_handle = photomath_agent.can_handle("test math problem", {"has_image": True})

        return {
            "success": True,
            "agent_id": photomath_agent.agent_id,
            "name": photomath_agent.name,
            "mode": "offline",
            "can_handle_score": can_handle,
            "supported_operations": photomath_agent.supported_operations
        }
    except Exception as e:
        logger.error(f"PhotoMath health check failed: {e}", exc_info=True)
        return JSONResponse(
            status_code=503,
            content={"success": False, "error": str(e)}
        )

class YouTubeSearchRequest(BaseModel):
    """Request model for YouTube search"""
    query: str = Field(..., description="Search query", min_length=1)
    max_results: int = Field(default=10, ge=1, le=50, description="Maximum results")
    language: str = Field(default='en', description="Preferred language")
    duration: str = Field(default='any', description="Duration filter (short/medium/long/any)")
    order: str = Field(default='relevance', description="Sort order (relevance/date/rating/viewCount)")
    use_online: bool = Field(default=True, description="Use YouTube API")

@app.post("/youtube/search")
@limiter.limit(RateLimits.DEFAULT)
async def youtube_search(
    request: Request,
    search_data: YouTubeSearchRequest
):
    """
    Search for educational videos

    - **query**: Search query
    - **max_results**: Maximum results (1-50)
    - **language**: Preferred language (en, hi, etc.)
    - **duration**: Duration filter (short/medium/long/any)
    - **order**: Sort order (relevance/date/rating/viewCount)
    - **use_online**: Use YouTube API if available
    """
    try:
        result = youtube_service.search_videos(
            query=search_data.query,
            max_results=search_data.max_results,
            language=search_data.language,
            duration=search_data.duration,
            order=search_data.order,
            use_online=search_data.use_online
        )

        logger.info(f"YouTube search: query='{search_data.query}', "
                   f"results={result.get('result_count', 0)}, "
                   f"provider={result.get('provider')}")

        return result

    except Exception as e:
        logger.error(f"YouTube search error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/youtube/video/{video_id}")
@limiter.limit(RateLimits.DEFAULT)
async def youtube_get_video(
    request: Request,
    video_id: str
):
    """
    Get video details

    - **video_id**: YouTube video ID
    """
    try:
        result = youtube_service.get_video_details(video_id)

        return result

    except Exception as e:
        logger.error(f"Failed to get video details: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/youtube/channels/{subject}")
@limiter.limit(RateLimits.DEFAULT)
async def youtube_get_channels(
    request: Request,
    subject: str
):
    """
    Get curated channel recommendations

    - **subject**: Subject area (Science/Mathematics/English/History/General)
    """
    try:
        channels = youtube_service.get_channel_recommendations(subject)

        return {
            "success": True,
            "subject": subject,
            "channel_count": len(channels),
            "channels": channels
        }

    except Exception as e:
        logger.error(f"Failed to get channels: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/youtube/health")
@limiter.limit(RateLimits.HEALTH)
async def youtube_health_check(request: Request):
    """Check YouTube service health"""
    try:
        health = youtube_service.health_check()
        return {"success": True, "health": health}
    except Exception as e:
        logger.error(f"YouTube health check failed: {e}", exc_info=True)
        return JSONResponse(
            status_code=503,
            content={"success": False, "error": str(e)}
        )

class FCMNotificationRequest(BaseModel):
    device_token: str = Field(..., description="FCM device token")
    title: str = Field(..., min_length=1, max_length=100)
    body: str = Field(..., min_length=1, max_length=500)
    data: Optional[Dict[str, str]] = Field(default=None, description="Custom data payload")
    image_url: Optional[str] = Field(default=None, description="Optional image URL")

class FCMTopicRequest(BaseModel):
    topic: str = Field(..., min_length=1, max_length=100, description="Topic name (e.g., 'class-10-A')")
    title: str = Field(..., min_length=1, max_length=100)
    body: str = Field(..., min_length=1, max_length=500)
    data: Optional[Dict[str, str]] = Field(default=None)
    image_url: Optional[str] = Field(default=None)

class FCMMulticastRequest(BaseModel):
    device_tokens: List[str] = Field(..., min_items=1, max_items=500)
    title: str = Field(..., min_length=1, max_length=100)
    body: str = Field(..., min_length=1, max_length=500)
    data: Optional[Dict[str, str]] = Field(default=None)

@app.post("/fcm/send")
@limiter.limit("10 per minute")
async def send_fcm_notification(req: FCMNotificationRequest, request: Request):
    """
    Send push notification to a single device

    Example:
    {
      "device_token": "dXXXX...",
      "title": "Attendance Alert",
      "body": "Your child was marked absent in Math class",
      "data": {"type": "attendance", "class": "10-A"},
      "image_url": "https://example.com/alert.png"
    }
    """
    try:
        security_logger.log_event("fcm_send", {
            "ip": request.client.host,
            "title": req.title
        })

        result = fcm_service.send_notification(
            device_token=req.device_token,
            title=req.title,
            body=req.body,
            data=req.data,
            image_url=req.image_url
        )

        if result.get("success"):
            return {"success": True, "message": "Notification sent successfully"}
        else:
            raise HTTPException(status_code=500, detail=result.get("error", "Failed to send notification"))

    except Exception as e:
        logger.error(f"FCM send failed: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/fcm/send-topic")
@limiter.limit("5 per minute")
async def send_fcm_to_topic(req: FCMTopicRequest, request: Request):
    """
    Send push notification to all devices subscribed to a topic

    Use cases:
    - Broadcast to entire class: topic = "class-10-A"
    - Alert all parents: topic = "parents"
    - Notify teachers: topic = "teachers"

    Example:
    {
      "topic": "class-10-A",
      "title": "Quiz Tomorrow",
      "body": "Math quiz on Chapter 5 tomorrow at 9 AM",
      "data": {"type": "quiz", "chapter": "5"}
    }
    """
    try:
        security_logger.log_event("fcm_topic_send", {
            "ip": request.client.host,
            "topic": req.topic,
            "title": req.title
        })

        result = fcm_service.send_to_topic(
            topic=req.topic,
            title=req.title,
            body=req.body,
            data=req.data,
            image_url=req.image_url
        )

        if result.get("success"):
            return {"success": True, "message": f"Notification sent to topic: {req.topic}"}
        else:
            raise HTTPException(status_code=500, detail=result.get("error", "Failed to send topic notification"))

    except Exception as e:
        logger.error(f"FCM topic send failed: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/fcm/send-multicast")
@limiter.limit("3 per minute")
async def send_fcm_multicast(req: FCMMulticastRequest, request: Request):
    """
    Send notification to multiple devices (up to 500)

    Example:
    {
      "device_tokens": ["token1", "token2", "token3"],
      "title": "Homework Due",
      "body": "Submit Math homework by 5 PM today"
    }
    """
    try:
        security_logger.log_event("fcm_multicast_send", {
            "ip": request.client.host,
            "device_count": len(req.device_tokens),
            "title": req.title
        })

        result = fcm_service.send_multicast(
            device_tokens=req.device_tokens,
            title=req.title,
            body=req.body,
            data=req.data
        )

        return {
            "success": True,
            "success_count": result.get("success_count", 0),
            "failure_count": result.get("failure_count", 0),
            "message": f"Sent to {result.get('success_count', 0)} devices"
        }

    except Exception as e:
        logger.error(f"FCM multicast failed: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/fcm/health")
@limiter.limit(RateLimits.HEALTH)
async def fcm_health_check(request: Request):
    """Check FCM service health"""
    try:
        is_configured = fcm_service.credentials is not None and fcm_service.project_id is not None

        return {
            "success": True,
            "fcm_configured": is_configured,
            "project_id": fcm_service.project_id if is_configured else None,
            "message": "FCM service is ready" if is_configured else "FCM service not configured (service account file missing)"
        }
    except Exception as e:
        logger.error(f"FCM health check failed: {e}", exc_info=True)
        return JSONResponse(
            status_code=503,
            content={"success": False, "error": str(e)}
        )

if __name__ == "__main__":
    import uvicorn
    logger.info("ðŸš€ Starting SIH2025 Backend Server...")
    uvicorn.run(app, host="0.0.0.0", port=8000, log_level="info")